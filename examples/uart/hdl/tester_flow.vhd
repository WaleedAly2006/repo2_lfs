-- VHDL Entity UART.tester.interface
--
-- Created:
--          by - user.group (host.domain)
--          at - 11:55:14 04/12/2005
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.1
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY tester IS
   PORT( 
      datout : IN     std_logic_vector (7 DOWNTO 0);  -- data to cpu
      int    : IN     std_logic;                      -- interrupt(1)
      sout   : IN     std_logic;                      -- serial output
      addr   : OUT    std_logic_vector (2 DOWNTO 0);  -- 3-bit address
      clk    : OUT    std_logic;                      -- 10 MHz clock
      cs     : OUT    std_logic;                      -- chip select
      datin  : OUT    std_logic_vector (7 DOWNTO 0);  -- data from cpu
      nrw    : OUT    std_logic;                      -- r(0), w(1)
      rst    : OUT    std_logic;                      -- reset(0)
      sin    : OUT    std_logic                       -- serial input
   );

-- Declarations

END tester ;

--
-- VHDL Architecture UART.tester.flow
--
-- Created:
--          by - user.group (host.domain)
--          at - 11:55:14 04/12/2005
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.1
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY std;
USE std.textio.all;
ARCHITECTURE flow OF tester IS
-- pragma synthesis_off
TYPE HDS_STATE_TYPE IS (state0,state1);
SIGNAL tester_top_current_state : HDS_STATE_TYPE;
-- pragma synthesis_on

   -- Architecture declarations
   SIGNAL int_clk : std_logic := '0';
   SIGNAL read_data : std_logic_vector(7 DOWNTO 0);
   CONSTANT CLK_PRD : time := 100 ns;
   CONSTANT DIV_LSB : std_logic_vector(7 DOWNTO 0):= "00000110";
   CONSTANT DIV_MSB : std_logic_vector(7 DOWNTO 0):= "00000000";
   CONSTANT SER_DATA : std_logic_vector(7 DOWNTO 0)  := "11001110";
   CONSTANT XMIT_DATA : std_logic_vector(7 DOWNTO 0) := "01011010";
   CONSTANT RCV_CLK_PRD : time := CLK_PRD * 6;

BEGIN

   -----------------------------------------------------------------
   tester_top_proc : PROCESS
   -----------------------------------------------------------------
-- pragma synthesis_off
TYPE HDS_INDEX IS RANGE 0 TO 10000;
TYPE HDS_PATH_ARRAY IS ARRAY (HDS_INDEX) OF integer;
TYPE HDS_TIME_ARRAY IS ARRAY (HDS_INDEX) OF time;
VARIABLE hds_paths : HDS_PATH_ARRAY;
VARIABLE hds_times : HDS_TIME_ARRAY;
VARIABLE hds_event_count : HDS_INDEX := 0;
PROCEDURE hds_event(id : integer) IS
BEGIN
   IF hds_event_count < 10000 THEN
      hds_paths(hds_event_count) := id;
      hds_times(hds_event_count) := now;
      hds_event_count := hds_event_count + 1;
      tester_top_current_state <= state0;
      tester_top_current_state <= state1;
   END IF;
END;
-- pragma synthesis_on

   -- Process declarations
   PROCEDURE uart_write (bit_data : std_logic_vector(7 DOWNTO 0);
                                            addr_w : natural) IS
    BEGIN
       addr <= CONV_STD_LOGIC_VECTOR(addr_w,3);
       nRW <= '1' AFTER CLK_PRD, '0' AFTER 8 * CLK_PRD;
       datin <= bit_data  AFTER CLK_PRD;
       cs <= '0' AFTER 2*CLK_PRD, '1' AFTER 7 * CLK_PRD;
       wait for 9 * CLK_PRD;
    END uart_write;
      
   PROCEDURE uart_read (addr_r : natural) IS
    BEGIN
        addr <= CONV_STD_LOGIC_VECTOR(addr_r,3);
        nRW <= '0' AFTER 2 * CLK_PRD;
        cs <= '0' AFTER 3*CLK_PRD, '1' AFTER 12 * CLK_PRD;
        wait for 10 * CLK_PRD;
        read_data <= datout;
        wait for 3 * CLK_PRD;
    END uart_read;


   BEGIN
      -- pragma synthesis_off
      hds_event(0);
      -- pragma synthesis_on
      -- pragma synthesis_off
      hds_event(1);
      -- pragma synthesis_on
      cs <= '1';
      nRW <= '0';
      addr <= "000";
      sin <= '1';
      rst <= '0', '1' AFTER 2 * CLK_PRD;
      datin <= "00000000" AFTER CLK_PRD;
      -- pragma synthesis_off
      hds_event(2);
      -- pragma synthesis_on
      wait for 5 * CLK_PRD;
      -- pragma synthesis_off
      hds_event(3);
      -- pragma synthesis_on
      uart_write(DIV_LSB,0);
      -- pragma synthesis_off
      hds_event(4);
      -- pragma synthesis_on
      wait for 7 * CLK_PRD;
      -- pragma synthesis_off
      hds_event(5);
      -- pragma synthesis_on
      uart_write(DIV_MSB,1);
      -- pragma synthesis_off
      hds_event(6);
      -- pragma synthesis_on
      wait for 7 * CLK_PRD;
      -- pragma synthesis_off
      hds_event(7);
      -- pragma synthesis_on

      -- pragma synthesis_off
      hds_event(8);
      -- pragma synthesis_on
      uart_write(XMIT_DATA,4);
      -- pragma synthesis_off
      hds_event(9);
      -- pragma synthesis_on
      wait on int for 60 * CLK_PRD;
      -- pragma synthesis_off
      hds_event(10);
      -- pragma synthesis_on
      IF int'event AND int = '1' THEN
         -- pragma synthesis_off
         hds_event(11);
         -- pragma synthesis_on
         wait on int_clk until int_clk = '0';
         -- pragma synthesis_off
         hds_event(12);
         -- pragma synthesis_on
         uart_read(7);
      ELSE
         -- pragma synthesis_off
         hds_event(13);
         -- pragma synthesis_on
         wait on int_clk until int_clk = '0';
         -- pragma synthesis_off
         hds_event(14);
         -- pragma synthesis_on
         assert false
            report "Interrupt did NOT occur"
            severity failure;
      END IF;

      -- pragma synthesis_off
      hds_event(15);
      -- pragma synthesis_on

      -- pragma synthesis_off
      hds_event(16);
      -- pragma synthesis_on
      sin <= '0';
      -- pragma synthesis_off
      hds_event(17);
      -- pragma synthesis_on
      wait for 3 * CLK_PRD;
      -- pragma synthesis_off
      hds_event(18);
      -- pragma synthesis_on
      l0: FOR i IN 0 TO 7 LOOP
         -- pragma synthesis_off
         hds_event(19);
         -- pragma synthesis_on
         sin <= SER_DATA(i);
         -- pragma synthesis_off
         hds_event(20);
         -- pragma synthesis_on
         wait for 6 * CLK_PRD;
      -- pragma synthesis_off
      hds_event(21);
      -- pragma synthesis_on
      END LOOP l0;
      -- pragma synthesis_off
      hds_event(22);
      -- pragma synthesis_on
      sin <= '1';
      -- pragma synthesis_off
      hds_event(23);
      -- pragma synthesis_on
      wait for 6 * CLK_PRD;
      -- pragma synthesis_off
      hds_event(24);
      -- pragma synthesis_on
      uart_read(7);
      -- pragma synthesis_off
      hds_event(25);
      -- pragma synthesis_on
      uart_read(5);
      -- pragma synthesis_off
      hds_event(26);
      -- pragma synthesis_on
      IF NOT(read_data = SER_DATA) THEN
         -- pragma synthesis_off
         hds_event(27);
         -- pragma synthesis_on
         assert false
            report "Read Data did NOT equal Serial Data"
            severity failure;
      END IF;

      -- pragma synthesis_off
      hds_event(28);
      -- pragma synthesis_on

      -- pragma synthesis_off
      hds_event(29);
      -- pragma synthesis_on
      uart_read(6);
      -- pragma synthesis_off
      hds_event(30);
      -- pragma synthesis_on
      IF NOT(read_data = "00000000") THEN
         -- pragma synthesis_off
         hds_event(31);
         -- pragma synthesis_on
         assert false
            report "Status NOT zero"
            severity failure;
      END IF;

      -- pragma synthesis_off
      hds_event(32);
      -- pragma synthesis_on
      assert false
         report "Uart Testing Complete"
         severity failure;
      -- pragma synthesis_off
      hds_event(33);
      -- pragma synthesis_on
      wait;
      -- pragma synthesis_off
      hds_event(34);
      -- pragma synthesis_on
   END PROCESS tester_top_proc;


-- Architecture concurrent statements
int_clk <= not int_clk AFTER CLK_PRD / 2;
clk <= int_clk;

END flow;
