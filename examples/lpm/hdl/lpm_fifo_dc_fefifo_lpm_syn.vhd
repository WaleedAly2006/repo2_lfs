-- VHDL Entity lpm.lpm_fifo_dc_fefifo.symbol
--
-- Created:
--          by - user.group (host.domain)
--          at - 09:12:44 02/18/03
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2003.1
--
LIBRARY IEEE;
USE IEEE.std_logic_1164.all;
USE IEEE.std_logic_arith.all;
USE IEEE.std_logic_unsigned.all;
LIBRARY lpm;
USE lpm.lpm_components.all;

ENTITY lpm_fifo_dc_fefifo IS
   GENERIC( 
      lpm_WIDTHAD        : natural;
      lpm_NUMWORDS       : natural;
      UNDERFLOW_CHECKING : string := "ON";
      lpm_MODE           : string
   );
   PORT( 
      USEDW_IN : IN     std_logic_vector (LPM_WIDTHAD-1 DOWNTO 0);
      WREQ     : IN     std_logic  := 'Z';
      RREQ     : IN     std_logic  := 'Z';
      EMPTY    : OUT    std_logic;
      FULL     : OUT    std_logic;
      CLOCK    : IN     std_logic;
      ACLR     : IN     std_logic  := '0'
   );

-- Declarations

END lpm_fifo_dc_fefifo ;


--------------------------------------------------------------------------
--   This VHDL file was developed by Altera Corporation.  It may be
-- freely copied and/or distributed at no cost.  Any persons using this
-- file for any purpose do so at their own risk, and are responsible for
-- the results of such use.  Altera Corporation does not guarantee that
-- this file is complete, correct, or fit for any particular purpose.
-- NO WARRANTY OF ANY KIND IS EXPRESSED OR IMPLIED.  This notice must
-- accompany any copy of this file.
--
--------------------------------------------------------------------------
-- LPM Synthesizable Models (Support string type generic)
-- These models are based on LPM version 220 (EIA-IS103 October 1998).
-------------------------------------------------------------------------
-- Version Quartus v1.1 (lpm 220)      Date 02/01/01
--------------------------------------------------------------------------
architecture lpm_syn of lpm_fifo_dc_fefifo is
signal usedw : std_logic_vector(LPM_WIDTHAD-1 downto 0);
signal sm_empty : std_logic_vector(1 downto 0) := "00";
signal lrreq : std_logic := '0'; -- DFF;
signal init : natural := 0;
signal i_empty : std_logic := '1';
signal i_full : std_logic := '0';
signal valid_rreq : std_logic;

begin

    valid_rreq <= rreq when underflow_checking = "OFF" else
                  rreq and not i_empty;

    process (clock, aclr)
    begin
        if (aclr = '1') then
            lrreq <= '0';
        elsif (clock'event and clock = '1' and NOW > 0 ns) then
            lrreq <= valid_rreq;
        end if;
    end process;

    process (clock, aclr)
    variable almost_full : integer := 0;
    begin
        if (aclr = '1') then
            i_full <= '0';
        elsif (clock'event and clock = '1' and NOW > 0 ns) then
            if (lpm_numwords >= 3) then
                almost_full := lpm_numwords-3;
            end if;
            if (unsigned(usedw) >= almost_full) then
                i_full <= '1';
            else
                i_full <= '0';
            end if;
        end if;
    end process;

    process (clock, aclr)
    variable local_sm_empty : std_logic_vector(1 downto 0) := "00";
    variable usedw_is_1 : boolean;
    begin
        local_sm_empty := sm_empty;
        if (aclr = '1') then
            local_sm_empty := "00";
        elsif (clock'event and clock = '1' and NOW > 0 ns) then
            if (lpm_mode = "READ") then
                case sm_empty is
                    when "00" =>                    -- state_empty
                        if (usedw /= 0) then
                            local_sm_empty := "01";
                        end if;
                    when "01" =>                    -- state_non_empty
                        usedw_is_1 := (usedw = 1 and lrreq = '0') or (usedw = 2 and lrreq = '1');
                        if (rreq = '1' and usedw_is_1) then
                            local_sm_empty := "10";
                        end if;
                    when "10" =>                    -- state_emptywait
                        if (usedw > 1) then
                            local_sm_empty := "01";
                        else
                            local_sm_empty := "00";
                        end if;
                    when others =>
                        -- INTERNAL ERROR
                end case;
            elsif (lpm_mode = "WRITE") then
                case sm_empty is
                    when "00" =>                    -- state_empty
                        if (wreq = '1') then
                            local_sm_empty := "01";
                        end if;
                    when "01" =>                    -- state_one
                        if (wreq = '0') then
                            local_sm_empty := "11";
                        end if;
                    when "11" =>                    -- state_non_empty
                        if (wreq = '1') then
                            local_sm_empty := "01";
                        elsif (usedw = 0) then
                            local_sm_empty := "00";
                        end if;
                    when others =>
                        -- INTERNAL ERROR
                end case;
            end if;
        end if;
        sm_empty <= local_sm_empty;
        i_empty <= not local_sm_empty(0);
    end process;

    usedw <= usedw_in;
    empty <= i_empty;
    full <= i_full;

end lpm_syn;
