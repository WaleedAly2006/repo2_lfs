-- VHDL Entity lpm.lpm_add_sub_signed.symbol
--
-- Created:
--          by - user.group (host.domain)
--          at - 09:12:42 02/18/03
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2003.1
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_signed.all;
LIBRARY lpm;
USE lpm.lpm_components.all;

ENTITY lpm_add_sub_signed IS
   GENERIC( 
      lpm_WIDTH     : positive;
      lpm_DIRECTION : string  := "UNUSED";
      lpm_TYPE      : string  := "LPM_ADD_SUB";
      lpm_PIPELINE  : integer := 0;
      lpm_HINT      : string  := "UNUSED"
   );
   PORT( 
      aclr     : IN     std_logic  := '0';
      add_sub  : IN     std_logic  := '1';
      cin      : IN     std_logic  := 'Z';
      clken    : IN     std_logic  := '1';
      clock    : IN     std_logic  := '0';
      dataa    : IN     std_logic_vector (lpm_WIDTH DOWNTO 1);
      datab    : IN     std_logic_vector (lpm_WIDTH DOWNTO 1);
      cout     : OUT    std_logic;
      overflow : OUT    std_logic;
      result   : OUT    std_logic_vector (lpm_WIDTH-1 DOWNTO 0)
   );

-- Declarations

END lpm_add_sub_signed ;


--------------------------------------------------------------------------
--   This VHDL file was developed by Altera Corporation.  It may be
-- freely copied and/or distributed at no cost.  Any persons using this
-- file for any purpose do so at their own risk, and are responsible for
-- the results of such use.  Altera Corporation does not guarantee that
-- this file is complete, correct, or fit for any particular purpose.
-- NO WARRANTY OF ANY KIND IS EXPRESSED OR IMPLIED.  This notice must
-- accompany any copy of this file.
--
--------------------------------------------------------------------------
-- LPM Synthesizable Models (Support string type generic)
-- These models are based on LPM version 220 (EIA-IS103 October 1998).
-------------------------------------------------------------------------
-- Version Quartus v1.1 (lpm 220)      Date 02/01/01
--------------------------------------------------------------------------
architecture lpm_syn of lpm_add_sub_signed is

signal A, B : std_logic_vector(LPM_WIDTH downto 0);
type t_resulttmp IS ARRAY (0 to LPM_PIPELINE) of std_logic_vector(LPM_WIDTH downto 0);

begin

	A <= (DATAA(LPM_WIDTH) & DATAA);
	B <= (DATAB(LPM_WIDTH) & DATAB);

	process(ACLR, CLOCK, A, B, CIN, ADD_SUB)
    variable resulttmp : t_resulttmp := (OTHERS => (OTHERS => '0'));
    variable couttmp : std_logic_vector(0 to LPM_PIPELINE) := (OTHERS => '0');
    variable overflowtmp : std_logic_vector(0 to LPM_PIPELINE) := (OTHERS => '0');
    variable i_cin : std_logic;
	begin
		if LPM_PIPELINE >= 0 then
			if LPM_DIRECTION = "ADD" or
               (LPM_DIRECTION = "UNUSED" and ADD_SUB = '1') then
                if (CIN = 'Z') then
                    i_cin := '0';
                else
                    i_cin := CIN;
                end if;

                resulttmp(LPM_PIPELINE) := A + B + i_cin;
				couttmp(LPM_PIPELINE) := resulttmp(LPM_PIPELINE)(LPM_WIDTH)
											xor DATAA(LPM_WIDTH)
											xor DATAB(LPM_WIDTH);
            elsif LPM_DIRECTION = "SUB" or
                  (LPM_DIRECTION = "UNUSED" and ADD_SUB = '0') then
                if (CIN = 'Z') then
                    i_cin := '1';
                else
                    i_cin := CIN;
                end if;

                resulttmp(LPM_PIPELINE) := A - B + i_cin - 1;
				couttmp(LPM_PIPELINE) := not resulttmp(LPM_PIPELINE)(LPM_WIDTH)
											xor DATAA(LPM_WIDTH)
											xor DATAB(LPM_WIDTH);
            elsif LPM_DIRECTION /= "UNUSED" then
                ASSERT FALSE
                REPORT "Illegal LPM_DIRECTION property value for LPM_ADD_SUB!"
                SEVERITY ERROR;
            end if;

			if (resulttmp(LPM_PIPELINE) > (2 ** (LPM_WIDTH-1)) -1) or
			   (resulttmp(LPM_PIPELINE) < -2 ** (LPM_WIDTH-1)) then

				overflowtmp(LPM_PIPELINE) := '1';
			else
				overflowtmp(LPM_PIPELINE) := '0';
			end if;

			if LPM_PIPELINE > 0 then
				if ACLR = '1' then
					overflowtmp := (OTHERS => '0');
					couttmp := (OTHERS => '0');
					for i in 0 to LPM_PIPELINE loop
						resulttmp(i) := (OTHERS => '0');
					end loop;
				elsif CLOCK'event and CLOCK = '1' and CLKEN = '1' then
					overflowtmp(0 to LPM_PIPELINE - 1) := overflowtmp(1 to LPM_PIPELINE);
					couttmp(0 to LPM_PIPELINE - 1) := couttmp(1 to LPM_PIPELINE);
					resulttmp(0 to LPM_PIPELINE - 1) := resulttmp(1 to LPM_PIPELINE);
				end if;
			end if;

            COUT <= couttmp(0);
			OVERFLOW <= overflowtmp(0);
			RESULT <= resulttmp(0)(LPM_WIDTH-1 downto 0);
		end if;
	end process;

end lpm_syn;
