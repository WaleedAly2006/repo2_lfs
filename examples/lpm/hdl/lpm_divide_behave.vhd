-- VHDL Entity lpm.lpm_divide.symbol
--
-- Created:
--          by - user.group (host.domain)
--          at - 09:12:44 02/18/03
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2003.1
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY lpm;
USE lpm.lpm_components.all;

ENTITY lpm_divide IS
   GENERIC( 
      lpm_WIDTHN            : natural;
      lpm_WIDTHD            : natural;
      lpm_NREPRESENTATION   : string  := "UNSIGNED";
      lpm_DREPRESENTATION   : string  := "UNSIGNED";
      lpm_REMAINDERPOSITIVE : string  := "TRUE";
      lpm_PIPELINE          : natural := 0;
      lpm_TYPE              : string  := "LPM_DIVIDE";
      lpm_HINT              : string  := "UNUSED"
   );
   PORT( 
      aclr     : IN     std_logic  := '0';
      clken    : IN     std_logic  := '1';
      clock    : IN     std_logic  := '0';
      denom    : IN     std_logic_vector (LPM_WIDTHD-1 DOWNTO 0);
      numer    : IN     std_logic_vector (lpm_WIDTHN-1 DOWNTO 0);
      quotient : OUT    std_logic_vector (lpm_WIDTHN-1 DOWNTO 0);
      remain   : OUT    std_logic_vector (lpm_WIDTHD-1 DOWNTO 0)
   );

-- Declarations

END lpm_divide ;


--------------------------------------------------------------------------
--   This VHDL file was developed by Altera Corporation.  It may be
-- freely copied and/or distributed at no cost.  Any persons using this
-- file for any purpose do so at their own risk, and are responsible for
-- the results of such use.  Altera Corporation does not guarantee that
-- this file is complete, correct, or fit for any particular purpose.
-- NO WARRANTY OF ANY KIND IS EXPRESSED OR IMPLIED.  This notice must
-- accompany any copy of this file.
--
--------------------------------------------------------------------------
-- LPM Synthesizable Models (Support string type generic)
-- These models are based on LPM version 220 (EIA-IS103 October 1998).
-------------------------------------------------------------------------
-- Version Quartus v1.1 (lpm 220)      Date 02/01/01
--------------------------------------------------------------------------
architecture behave of lpm_divide is

type qpipeline is array (0 to LPM_PIPELINE) of std_logic_vector(LPM_WIDTHN-1 downto 0);
type rpipeline is array (0 to LPM_PIPELINE) of std_logic_vector(LPM_WIDTHD-1 downto 0);

begin

	process (aclr, clock, numer, denom)
	variable tmp_quotient : qpipeline;
	variable tmp_remain : rpipeline;
    variable int_numer, int_denom, int_quotient, int_remain : integer := 0;
	variable signed_quotient : signed(LPM_WIDTHN-1 downto 0);
	variable unsigned_quotient : unsigned(LPM_WIDTHN-1 downto 0);
	begin
        if (LPM_NREPRESENTATION = "UNSIGNED") then
			int_numer := conv_integer(unsigned(numer));
        elsif (LPM_NREPRESENTATION = "SIGNED") then
			int_numer := conv_integer(signed(numer));
        else
            ASSERT FALSE
            REPORT "Illegal LPM_NREPRESENTATION property value for LPM_DIVIDE!"
            SEVERITY ERROR;
		end if;
        if (LPM_DREPRESENTATION = "UNSIGNED" ) then
			int_denom := conv_integer(unsigned(denom));
        elsif (LPM_DREPRESENTATION = "SIGNED") then
			int_denom := conv_integer(signed(denom));
        else
            ASSERT FALSE
            REPORT "Illegal LPM_DREPRESENTATION property value for LPM_DIVIDE!"
            SEVERITY ERROR;
		end if;
		if int_denom = 0 then
			int_quotient := 0;
			int_remain := 0;
		else
            int_quotient := int_numer / int_denom;
            int_remain := int_numer rem int_denom;

            -- LPM 220 standard
            if ((LPM_REMAINDERPOSITIVE = "TRUE") and (int_remain < 0)) then
                if int_denom < 0 then
                    int_quotient := int_quotient + 1;
                else
                    int_quotient := int_quotient - 1;
                end if;
                int_remain := int_numer - int_quotient*int_denom;
            end if;
		end if;
		signed_quotient := conv_signed(int_quotient, LPM_WIDTHN);
		unsigned_quotient := conv_unsigned(int_quotient, LPM_WIDTHN);

        tmp_remain(LPM_PIPELINE) := conv_std_logic_vector(int_Remain, LPM_WIDTHD);
        if ((LPM_NREPRESENTATION = "UNSIGNED") and (LPM_DREPRESENTATION = "UNSIGNED")) then
            tmp_quotient(LPM_PIPELINE) := conv_std_logic_vector(unsigned_quotient, LPM_WIDTHN);
		else
            tmp_quotient(LPM_PIPELINE) := conv_std_logic_vector(signed_quotient, LPM_WIDTHN);
		end if;
	  
        if LPM_PIPELINE > 0 then
			if aclr = '1' then
                for i in 0 to LPM_PIPELINE loop
					tmp_quotient(i) := (OTHERS => '0');
					tmp_remain(i) := (OTHERS => '0');
				end loop;
			elsif clock'event and clock = '1' then
				if clken = '1' then
                    tmp_quotient(0 to LPM_PIPELINE-1) := tmp_quotient(1 to LPM_PIPELINE);
                    tmp_remain(0 to LPM_PIPELINE-1) := tmp_remain(1 to LPM_PIPELINE);
				end if;
			end if;
		end if;
		
		quotient <= tmp_quotient(0);
		remain <= tmp_remain(0);
	end process;

end behave;
