-- VHDL Entity lpm.lpm_fifo_dc.symbol
--
-- Created:
--          by - user.group (host.domain)
--          at - 09:12:44 02/18/03
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2003.1
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
USE ieee.std_logic_arith.all;
LIBRARY lpm;
USE lpm.lpm_components.all;

ENTITY lpm_fifo_dc IS
   GENERIC( 
      lpm_WIDTH          : natural;
      lpm_WIDTHU         : natural := 1;
      lpm_NUMWORDS       : natural;
      lpm_SHOWAHEAD      : string  := "OFF";
      lpm_TYPE           : string  := "LPM_FIFO_DC";
      UNDERFLOW_CHECKING : string  := "ON";
      OVERFLOW_CHECKING  : string  := "ON";
      lpm_HINT           : string  := "UNUSED"
   );
   PORT( 
      aclr    : IN     std_logic  := '0';
      data    : IN     std_logic_vector (lpm_WIDTH-1 DOWNTO 0);
      rdclock : IN     std_logic;
      rdreq   : IN     std_logic;
      wrclock : IN     std_logic;
      wrreq   : IN     std_logic;
      q       : OUT    std_logic_vector (lpm_WIDTH-1 DOWNTO 0);
      rdempty : OUT    std_logic;
      rdfull  : OUT    std_logic;
      rdusedw : OUT    std_logic_vector (lpm_WIDTHU-1 DOWNTO 0);
      wrempty : OUT    std_logic;
      wrfull  : OUT    std_logic;
      wrusedw : OUT    std_logic_vector (lpm_WIDTHU-1 DOWNTO 0)
   );

-- Declarations

END lpm_fifo_dc ;


--------------------------------------------------------------------------
--   This VHDL file was developed by Altera Corporation.  It may be
-- freely copied and/or distributed at no cost.  Any persons using this
-- file for any purpose do so at their own risk, and are responsible for
-- the results of such use.  Altera Corporation does not guarantee that
-- this file is complete, correct, or fit for any particular purpose.
-- NO WARRANTY OF ANY KIND IS EXPRESSED OR IMPLIED.  This notice must
-- accompany any copy of this file.
--
--------------------------------------------------------------------------
-- LPM Synthesizable Models (Support string type generic)
-- These models are based on LPM version 220 (EIA-IS103 October 1998).
-------------------------------------------------------------------------
-- Version Quartus v1.1 (lpm 220)      Date 02/01/01
--------------------------------------------------------------------------
architecture lpm_syn of lpm_fifo_dc is

type lpm_memory is array (2**lpm_widthu-1 downto 0) of std_logic_vector(lpm_width-1 downto 0);

signal i_q : std_logic_vector(lpm_width-1 downto 0) := (OTHERS => '0');
signal i_rdptr, i_wrptr, i_rdptrrg, i_wrdelaycycle : integer := 0;
signal i_ws_nbrp, i_rs_nbwp, i_ws_dbrp, i_rs_dbwp : integer := 0;
signal i_wr_udwn, i_rd_udwn, i_wr_dbuw, i_rd_dbuw : integer := 0;
signal i_rdempty, i_wrempty : std_logic := '1';
signal i_rdfull, i_wrfull : std_logic := '0';
signal i_rdusedw, i_wrusedw : integer := 0;
signal i_rden, i_wren, i_rdenclock : std_logic := '0';
signal slv_wr_dbuw, slv_rd_dbuw : std_logic_vector(lpm_widthu-1 downto 0);

signal i_data_tmp, i_data_reg : std_logic_vector(lpm_width-1 downto 0) := (OTHERS => '0');
signal i_q_tmp, i_q_reg : std_logic_vector(lpm_width-1 downto 0) := (OTHERS => '0');
signal i_rdptr_tmp, i_wrptr_tmp, i_wrptr_reg : integer := 0;
signal i_wren_tmp, i_wren_reg : std_logic := '0';

constant ZEROS : std_logic_vector(lpm_width-1 downto 0) := (OTHERS => '0');
constant WRSYNC_DELAYPIPE : integer := 3;   -- from the rdclk to the wrclk subsystem
constant RDSYNC_DELAYPIPE : integer := 3;   -- from the wrclk to the rdclk subsystem
constant GRAY_DELAYPIPE : integer := 1;
constant DELAY_WRUSEDW : integer := 1;      -- output delay to the wrusedw outputs
constant DELAY_RDUSEDW : integer := 1;      -- output delay to the rdusedw outputs
constant WRUSEDW_DELAYPIPE : integer := 1;  -- delayed usedw to compute empty/full
constant RDUSEDW_DELAYPIPE : integer := 1;  -- delayed usedw to compute empty/full

component LPM_FIFO_DC_FEFIFO
    generic (LPM_WIDTHAD : natural;
             LPM_NUMWORDS : natural;
  	     UNDERFLOW_CHECKING : STRING := "ON"; 
             LPM_MODE : string);
    port (USEDW_IN : in std_logic_vector(LPM_WIDTHAD-1 downto 0);
          WREQ : in std_logic := 'Z';
          RREQ : in std_logic := 'Z';
          EMPTY : out std_logic;
          FULL : out std_logic;
          CLOCK : in std_logic;
          ACLR : in std_logic := '0');
end component;

component LPM_FIFO_DC_DFFPIPE
    generic (LPM_DELAY : natural);
    port (D : in integer;
          Q : out integer := 0;
          CLOCK : in std_logic;
          ACLR : in std_logic := '0');
end component;

begin

    ----------
    -- FIFOram
    ----------

    i_rden <= rdreq when underflow_checking = "OFF" else
              rdreq and not i_rdempty;
    i_wren <= wrreq when overflow_checking = "OFF" else
              wrreq and not i_wrfull;

    FIFOram_sync: process (i_data_reg, i_q_tmp, i_q_reg, aclr,
                           i_rdptr, i_wren_reg, i_wrptr_reg)
    begin
        if (aclr = '1') then
            i_wrptr_tmp <= 0;
            i_rdptr_tmp <= 0;
            i_wren_tmp <= '0';
            i_data_tmp <= (OTHERS => '0');
            if (LPM_SHOWAHEAD = "ON") then
                i_q <= i_q_tmp;
            else
                i_q <= (OTHERS => '0');
            end if;
        else
            i_wrptr_tmp <= i_wrptr_reg;
            i_rdptr_tmp <= i_rdptr;
            i_wren_tmp <= i_wren_reg;
            i_data_tmp <= i_data_reg;
            if (LPM_SHOWAHEAD = "ON") then
                i_q <= i_q_tmp;
            else
                i_q <= i_q_reg;
            end if;
        end if;
    end process;

    FIFOram_wrclock: process (wrclock, aclr)
    begin
        if (aclr = '1') then
            i_data_reg <= (OTHERS => '0');
            i_wrptr_reg <= 0;
            i_wren_reg <= '0';
        elsif (wrclock'event and wrclock = '1' and NOW > 0 ns) then
            i_data_reg <= data;
            i_wrptr_reg <= i_wrptr;
            i_wren_reg <= i_wren;
        end if;
    end process;

    FIFOram_rdclock: process (rdclock, aclr)
    begin
        if (aclr = '1') then
            i_q_reg <= (OTHERS => '0');
        elsif (rdclock'event and rdclock = '1' and i_rden = '1' and NOW > 0 ns) then
            i_q_reg <= i_q_tmp;
        end if;
    end process;

    FIFOram_memory: process (i_data_tmp, i_wren_tmp, i_wrptr_tmp, i_rdptr_tmp, wrclock)
    variable mem_data : lpm_memory := (OTHERS => ZEROS);
    variable init : integer := 0;
    begin
        if (init = 0) then
            for i in lpm_numwords-1 downto 0 loop
                mem_data(i) := ZEROS;
            end loop;
            init := 1;
        end if;
        if wrclock'event and i_wren_tmp = '1' and
            ((wrclock = '0' and lpm_hint = "USE_EAB=ON") or
             (wrclock = '1' and lpm_hint /= "USE_EAB=ON")) then
                mem_data(i_wrptr_tmp) := i_data_tmp;
        end if;
        i_q_tmp <= mem_data(i_rdptr_tmp);
    end process;


    -----------
    -- Counters
    -----------

    rdptr: process (rdclock, aclr)
    begin
        if (aclr = '1') then
            i_rdptr <= 0;
        elsif (rdclock'event and rdclock = '1' and i_rden = '1' and NOW > 0 ns) then
            if (i_rdptr < 2**lpm_widthu-1) then
                i_rdptr <= i_rdptr + 1;
            else
                i_rdptr <= 0;
            end if;
        end if;
    end process;

    wrptr: process (wrclock, aclr)
    begin
        if (aclr = '1') then
            i_wrptr <= 0;
        elsif (wrclock'event and wrclock = '1' and i_wren = '1' and NOW > 0 ns) then
            if (i_wrptr < 2**lpm_widthu-1) then
                i_wrptr <= i_wrptr + 1;
            else
                i_wrptr <= 0;
            end if;
        end if;
    end process;


    ---------------------
    -- Delays & DFF Pipes
    ---------------------

    process (rdclock)
    begin
        if (rdclock = '0') then
            i_rdenclock <= '0';
        elsif (rdclock = '1' and i_rden = '1') then
            i_rdenclock <= '1';
        end if;
    end process;

    RDPTR_D:    LPM_FIFO_DC_DFFPIPE
                    generic map (LPM_DELAY => 0)
                    port map (D => i_rdptr, Q => i_rdptrrg,
                              CLOCK => i_rdenclock, ACLR => aclr);

    WRPTR_D:    LPM_FIFO_DC_DFFPIPE
                    generic map (LPM_DELAY => 1)
                    port map (D => i_wrptr, Q => i_wrdelaycycle,
                              CLOCK => wrclock, ACLR => aclr);

    WS_NBRP:    LPM_FIFO_DC_DFFPIPE
                    generic map (LPM_DELAY => WRSYNC_DELAYPIPE)
                    port map (D => i_rdptrrg, Q => i_ws_nbrp,
                              CLOCK => wrclock, ACLR => aclr);

    RS_NBWP:    LPM_FIFO_DC_DFFPIPE
                    generic map (LPM_DELAY => RDSYNC_DELAYPIPE)
                    port map (D => i_wrdelaycycle, Q => i_rs_nbwp,
                              CLOCK => rdclock, ACLR => aclr);

    WS_DBRP:    LPM_FIFO_DC_DFFPIPE
                    generic map (LPM_DELAY => GRAY_DELAYPIPE)
                    port map (D => i_ws_nbrp, Q => i_ws_dbrp,
                              CLOCK => wrclock, ACLR => aclr);

    RS_DBWP:    LPM_FIFO_DC_DFFPIPE
                    generic map (LPM_DELAY => GRAY_DELAYPIPE)
                    port map (D => i_rs_nbwp, Q => i_rs_dbwp,
                              CLOCK => rdclock, ACLR => aclr);

    process (i_wrptr, i_ws_dbrp)
    begin
        i_wr_udwn <= i_wrptr - i_ws_dbrp;
    end process;
            
    process (i_rdptr, i_rs_dbwp)
    begin
        i_rd_udwn <= i_rs_dbwp - i_rdptr;
    end process;
            
    WR_USEDW:   LPM_FIFO_DC_DFFPIPE
                    generic map (LPM_DELAY => DELAY_WRUSEDW)
                    port map (D => i_wr_udwn, Q => i_wrusedw,
                              CLOCK => wrclock, ACLR => aclr);

    RD_USEDW:   LPM_FIFO_DC_DFFPIPE
                    generic map (LPM_DELAY => DELAY_RDUSEDW)
                    port map (D => i_rd_udwn, Q => i_rdusedw,
                              CLOCK => rdclock, ACLR => aclr);

    WR_DBUW:    LPM_FIFO_DC_DFFPIPE
                    generic map (LPM_DELAY => WRUSEDW_DELAYPIPE)
                    port map (D => i_wr_udwn, Q => i_wr_dbuw,
                              CLOCK => wrclock, ACLR => aclr);

    RD_DBUW:    LPM_FIFO_DC_DFFPIPE
                    generic map (LPM_DELAY => RDUSEDW_DELAYPIPE)
                    port map (D => i_rd_udwn, Q => i_rd_dbuw,
                              CLOCK => rdclock, ACLR => aclr);


    -------------
    -- Full/Empty
    -------------

    slv_wr_dbuw <= conv_std_logic_vector(i_wr_dbuw, LPM_WIDTHU);
    slv_rd_dbuw <= conv_std_logic_vector(i_rd_dbuw, LPM_WIDTHU);

    WR_FE:  LPM_FIFO_DC_FEFIFO
                generic map (LPM_WIDTHAD => LPM_WIDTHU,
                             LPM_NUMWORDS => LPM_NUMWORDS,
                             LPM_MODE => "WRITE",
                             UNDERFLOW_CHECKING => UNDERFLOW_CHECKING)
                port map (USEDW_IN => slv_wr_dbuw, WREQ => wrreq,
                          CLOCK => wrclock, ACLR => aclr,
                          EMPTY => i_wrempty, FULL => i_wrfull);

    RD_FE:  LPM_FIFO_DC_FEFIFO
                generic map (LPM_WIDTHAD => LPM_WIDTHU,
                             LPM_NUMWORDS => LPM_NUMWORDS,
                             LPM_MODE => "READ",
                             UNDERFLOW_CHECKING => UNDERFLOW_CHECKING)
                port map (USEDW_IN => slv_rd_dbuw, RREQ => rdreq,
                          CLOCK => rdclock, ACLR => aclr,
                          EMPTY => i_rdempty, FULL => i_rdfull);

    ----------
    -- Outputs
    ----------

    q <= i_q;
    wrfull <= i_wrfull;
    wrempty <= i_wrempty;
    rdfull <= i_rdfull;
    rdempty <= i_rdempty;
    wrusedw <= conv_std_logic_vector(i_wrusedw, LPM_WIDTHU);
    rdusedw <= conv_std_logic_vector(i_rdusedw, LPM_WIDTHU);

end lpm_syn;
