--
-- VHDL Entity UART.tester.interface
--
-- Created:
--          by - user.group (host.domain)
--          at - 17:25:34 12/06/2001
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2001.5
--
-- hds interface_start
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY tester IS
   PORT( 
      data_out : IN     std_logic_vector (7 DOWNTO 0);
      int      : IN     std_logic;
      sout     : IN     std_logic;
      addr     : OUT    std_logic_vector (2 DOWNTO 0);
      clk      : OUT    std_logic;
      cs       : OUT    std_logic;
      data_in  : OUT    std_logic_vector (7 DOWNTO 0);
      nrw      : OUT    std_logic;
      rst      : OUT    std_logic;
      sin      : OUT    std_logic
   );

-- Declarations

END tester ;

-- hds interface_end
--
-- VHDL Architecture UART.tester.flow
--
-- Created:
--          by - user.group (host.domain)
--          at - 17:25:34 12/06/2001
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2001.5
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
LIBRARY std;
USE std.textio.all;
ARCHITECTURE flow OF tester IS
-- pragma synthesis_off
TYPE hds_state_type IS (state0,state1);
SIGNAL tester_top_current_state : hds_state_type;
-- pragma synthesis_on

   -- Architecture declarations
   SIGNAL int_clk : std_logic := '0';
   
   CONSTANT clk_prd : time := 100 ns;
   CONSTANT div_lsb : std_logic_vector(7 DOWNTO 0):= "00000110";
   CONSTANT div_msb : std_logic_vector(7 DOWNTO 0):= "00000000";
   CONSTANT ser_data : std_logic_vector(7 DOWNTO 0)  := "11001110";
   CONSTANT xmit_data : std_logic_vector(7 DOWNTO 0) := "01011010";
   
   CONSTANT rcv_clk_prd : time := clk_prd * 6;

BEGIN

   ---------------------------------------------------------------------------
   tester_top : PROCESS
   ---------------------------------------------------------------------------
-- pragma synthesis_off
TYPE hds_index IS RANGE 0 TO 10000;
TYPE hds_path_array IS ARRAY (hds_index) OF integer;
TYPE hds_time_array IS ARRAY (hds_index) OF time;
VARIABLE hds_paths : hds_path_array;
VARIABLE hds_times : hds_time_array;
VARIABLE hds_event_count : hds_index := 0;
PROCEDURE hds_event(id : integer) IS
BEGIN
   IF hds_event_count < 10000 THEN
      hds_paths(hds_event_count) := id;
      hds_times(hds_event_count) := now;
      hds_event_count := hds_event_count + 1;
      tester_top_current_state <= state0;
      tester_top_current_state <= state1;
   END IF;
END;
-- pragma synthesis_on

   -- Process declarations
   VARIABLE read_data : std_logic_vector(7 DOWNTO 0);
      
   PROCEDURE uart_write (bit_data : std_logic_vector(7 DOWNTO 0);
                                            address : natural) IS
    BEGIN
       addr <= CONV_STD_LOGIC_VECTOR(address,3);
       nRW <= '1' AFTER clk_prd, '0' AFTER 8 * clk_prd;
       data_in <= bit_data  AFTER clk_prd;
       cs <= '0' AFTER 2*clk_prd, '1' AFTER 7 * clk_prd;
       wait for 9 * clk_prd;
    END uart_write;
      
   PROCEDURE uart_read (address : natural ; data_out : std_logic_vector(7 downto 0)) IS
    BEGIN
        addr <= CONV_STD_LOGIC_VECTOR(address,3);
        nRW <= '0' AFTER 2 * clk_prd;
        cs <= '0' AFTER 3*clk_prd, '1' AFTER 12 * clk_prd;
        wait for 10 * clk_prd;
        read_data := data_out;
        wait for 3 * clk_prd;
    END uart_read;


   BEGIN
      -- pragma synthesis_off
      hds_event(0);
      -- pragma synthesis_on
      -- pragma synthesis_off
      hds_event(1);
      -- pragma synthesis_on
      cs <= '1';
      nRW <= '0';
      addr <= "000";
      sin <= '1';
      rst <= '0', '1' AFTER 2 * clk_prd;
      data_in <= "00000000" AFTER clk_prd;
      -- pragma synthesis_off
      hds_event(2);
      -- pragma synthesis_on
      wait for 5 * clk_prd;
      -- pragma synthesis_off
      hds_event(3);
      -- pragma synthesis_on
      uart_write(div_lsb,0);
      -- pragma synthesis_off
      hds_event(4);
      -- pragma synthesis_on
      wait for 7 * clk_prd;
      -- pragma synthesis_off
      hds_event(5);
      -- pragma synthesis_on
      uart_write(div_msb,1);
      -- pragma synthesis_off
      hds_event(6);
      -- pragma synthesis_on
      wait for 7 * clk_prd;
      -- pragma synthesis_off
      hds_event(7);
      -- pragma synthesis_on

      -- pragma synthesis_off
      hds_event(8);
      -- pragma synthesis_on
      uart_write(xmit_data,4);
      -- pragma synthesis_off
      hds_event(9);
      -- pragma synthesis_on
      wait on int for 60 * clk_prd;
      -- pragma synthesis_off
      hds_event(10);
      -- pragma synthesis_on
      IF int'event AND int = '1' THEN
         -- pragma synthesis_off
         hds_event(11);
         -- pragma synthesis_on
         wait on int_clk until int_clk = '0';
         -- pragma synthesis_off
         hds_event(12);
         -- pragma synthesis_on
         uart_read(7, data_out);
      ELSE
         -- pragma synthesis_off
         hds_event(13);
         -- pragma synthesis_on
         wait on int_clk until int_clk = '0';
         -- pragma synthesis_off
         hds_event(14);
         -- pragma synthesis_on
         assert false
            report "Interrupt did NOT occur"
            severity failure;
      END IF;

      -- pragma synthesis_off
      hds_event(15);
      -- pragma synthesis_on

      -- pragma synthesis_off
      hds_event(16);
      -- pragma synthesis_on
      sin <= '0';
      -- pragma synthesis_off
      hds_event(17);
      -- pragma synthesis_on
      wait for 3 * clk_prd;
      -- pragma synthesis_off
      hds_event(18);
      -- pragma synthesis_on
      l0: FOR i IN 0 TO 7 LOOP
         -- pragma synthesis_off
         hds_event(19);
         -- pragma synthesis_on
         sin <= ser_data(i);
         -- pragma synthesis_off
         hds_event(20);
         -- pragma synthesis_on
         wait for 6 * clk_prd;
      -- pragma synthesis_off
      hds_event(21);
      -- pragma synthesis_on
      END LOOP l0;
      -- pragma synthesis_off
      hds_event(22);
      -- pragma synthesis_on
      sin <= '1';
      -- pragma synthesis_off
      hds_event(23);
      -- pragma synthesis_on
      wait for 6 * clk_prd;
      -- pragma synthesis_off
      hds_event(24);
      -- pragma synthesis_on
      uart_read(7, data_out);
      -- pragma synthesis_off
      hds_event(25);
      -- pragma synthesis_on
      uart_read(5, data_out);
      -- pragma synthesis_off
      hds_event(26);
      -- pragma synthesis_on
      IF NOT(read_data = ser_data) THEN
         -- pragma synthesis_off
         hds_event(27);
         -- pragma synthesis_on
         assert false
            report "Read Data did NOT equal Serial Data"
            severity failure;
      END IF;

      -- pragma synthesis_off
      hds_event(28);
      -- pragma synthesis_on

      -- pragma synthesis_off
      hds_event(29);
      -- pragma synthesis_on
      uart_read(6, data_out);
      -- pragma synthesis_off
      hds_event(30);
      -- pragma synthesis_on
      IF NOT(read_data = "00000000") THEN
         -- pragma synthesis_off
         hds_event(31);
         -- pragma synthesis_on
         assert false
            report "Status NOT zero"
            severity failure;
      END IF;

      -- pragma synthesis_off
      hds_event(32);
      -- pragma synthesis_on
      assert false
         report "Uart Testing Complete"
         severity failure;
      -- pragma synthesis_off
      hds_event(33);
      -- pragma synthesis_on
      wait;
      -- pragma synthesis_off
      hds_event(34);
      -- pragma synthesis_on
   END PROCESS tester_top;


-- Architecture concurrent statements
int_clk <= not int_clk AFTER clk_prd / 2;
clk <= int_clk;

END flow;
