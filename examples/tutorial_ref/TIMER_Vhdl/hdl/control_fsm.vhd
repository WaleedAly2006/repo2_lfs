-- VHDL Entity TIMER_Vhdl.Control.interface
--
-- Created:
--          by - user.group (host.domain)
--          at - 11:40:30 04/12/2005
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.1
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY Control IS
   PORT( 
      clk   : IN     std_logic;
      d     : IN     std_logic_vector (9 DOWNTO 0);
      reset : IN     std_logic;
      start : IN     std_logic;
      stop  : IN     std_logic;
      zero  : IN     std_logic;
      beep  : OUT    std_logic;
      clear : OUT    std_logic;
      hold  : OUT    std_logic;
      load  : OUT    std_logic
   );

-- Declarations

END Control ;

--
-- VHDL Architecture TIMER_Vhdl.Control.fsm
--
-- Created:
--          by - user.group (host.domain)
--          at - 11:40:31 04/12/2005
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.1
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
 
ARCHITECTURE fsm OF Control IS

   -- Architecture Declarations
   Constant NOUGHTS : std_logic_vector := "0000000000";

   TYPE STATE_TYPE IS (
      getkey,
      flush,
      load_t,
      load_u,
      standby,
      alarm,
      counting,
      suspended,
      end_count
   );
 
   -- State vector declaration
   ATTRIBUTE state_vector : string;
   ATTRIBUTE state_vector OF fsm : ARCHITECTURE IS "current_state";

   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

   -- Declare any pre-registered internal signals
   SIGNAL beep_int : std_logic ;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk,
      reset
   )
   -----------------------------------------------------------------
   BEGIN
      IF (reset = '1') THEN
         current_state <= flush;
         -- Default Reset Values
         beep <= '0';
      ELSIF (clk'EVENT AND clk = '0') THEN
         current_state <= next_state;
         -- Registered output assignments
         beep <= beep_int;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      current_state,
      d,
      start,
      stop,
      zero
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN getkey => 
            IF (start='1') THEN 
               next_state <= standby;
            ELSIF (d/=NOUGHTS) THEN 
               next_state <= load_u;
            ELSIF (stop='1') THEN 
               next_state <= flush;
            ELSE
               next_state <= getkey;
            END IF;
         WHEN flush => 
            IF (d/=NOUGHTS) THEN 
               next_state <= load_u;
            ELSE
               next_state <= flush;
            END IF;
         WHEN load_t => 
            IF (d/=NOUGHTS) THEN 
               next_state <= getkey;
            ELSE
               next_state <= load_t;
            END IF;
         WHEN load_u => 
            next_state <= load_t;
         WHEN standby => 
            IF (zero='1') THEN 
               next_state <= alarm;
            ELSIF (start='1') THEN 
               next_state <= counting;
            ELSE
               next_state <= standby;
            END IF;
         WHEN alarm => 
            IF (stop='1') THEN 
               next_state <= end_count;
            ELSE
               next_state <= alarm;
            END IF;
         WHEN counting => 
            IF (zero='1') THEN 
               next_state <= alarm;
            ELSIF (stop='1') THEN 
               next_state <= suspended;
            ELSE
               next_state <= counting;
            END IF;
         WHEN suspended => 
            IF (stop='0') THEN 
               next_state <= counting;
            ELSE
               next_state <= suspended;
            END IF;
         WHEN end_count => 
            IF (stop='1') THEN 
               next_state <= flush;
            ELSE
               next_state <= end_count;
            END IF;
         WHEN OTHERS =>
            next_state <= flush;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      beep_int <= '0';
      clear <= '0';
      hold <= '0';
      load <= '0';

      -- Combined Actions
      CASE current_state IS
         WHEN getkey => 
            hold<='1';
         WHEN flush => 
            hold<='1';
            clear<='1';
            beep_int<='0';
         WHEN load_t => 
            hold<='1';
         WHEN load_u => 
            hold<='1';
            load<='1';
         WHEN standby => 
            hold<='1';
         WHEN alarm => 
            hold<='1';
            clear<= '1';
            beep_int <= '1';
         WHEN suspended => 
            hold<='1';
         WHEN end_count => 
            hold<='1';
            clear<= '1';
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
END fsm;
