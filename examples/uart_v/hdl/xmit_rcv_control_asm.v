//
// Module UART_V.xmit_rcv_control.asm
//
// Created:
//          by - user.group (host.domain)
//          at - 13:48:39 15/06/2004
//
// Generated by Mentor Graphics' HDL Designer(TM) 2004.1
//

`resetall
`timescale 1ns/10ps
module xmit_rcv_control( 
   clk, 
   rst, 
   sample, 
   sin, 
   start_xmit, 
   xmitdt, 
   done_rcving, 
   done_xmitting, 
   enable_rcv_clk, 
   enable_xmit_clk, 
   rcv_bit_cnt, 
   rcving, 
   read_bit, 
   sout, 
   xmitting
);


// Internal Declarations

input        clk;
input        rst;
input        sample;
input        sin;
input        start_xmit;
input  [7:0] xmitdt;
output       done_rcving;
output       done_xmitting;
output       enable_rcv_clk;
output       enable_xmit_clk;
output [2:0] rcv_bit_cnt;
output       rcving;
output       read_bit;
output       sout;
output       xmitting;


wire clk;
wire rst;
wire sample;
wire sin;
wire start_xmit;
wire [7:0] xmitdt;
reg done_rcving;
reg done_xmitting;
reg enable_rcv_clk;
reg enable_xmit_clk;
reg [2:0] rcv_bit_cnt;
reg rcving;
reg read_bit;
reg sout;
reg xmitting;
// Declare any pre-registered internal signals
reg enable_xmit_clk_cld;
reg [2:0] rcv_bit_cnt_cld;
reg sout_cld;
reg xmitting_cld;

// Module Declarations
reg [2:0] xmit_bit_cnt;  

// State encoding
parameter [2:0] // pragma enum rcv_current_state_code
          waiting       = 3'd0,
          check_lock    = 3'd1,
          rcv_locked    = 3'd2,
          read_data     = 3'd3,
          incr_count2   = 3'd4,
          done_read     = 3'd5,
          read_stop_bit = 3'd6,
          finish_rcv    = 3'd7;

// State encoding
parameter [2:0] // pragma enum xmit_current_state_code
          waiting_to_xmit = 3'd0,
          send_start      = 3'd1,
          send_data       = 3'd2,
          incr_count      = 3'd3,
          done_xmit       = 3'd4,
          send_stop_bit   = 3'd5,
          finish_xmit     = 3'd6;

reg [2:0] /* pragma enum rcv_current_state_code */ rcv_current_state, rcv_next_state;

reg [2:0] /* pragma enum xmit_current_state_code */ xmit_current_state, xmit_next_state;

//-----------------------------------------------------------------
// Next State Block for machine rcv
//-----------------------------------------------------------------
always @(
   rcv_bit_cnt_cld or 
   rcv_current_state or 
   sample or 
   sin
)
begin : rcv_nextstate_proc
   case (rcv_current_state) 
      waiting: 
         if (~sin) 
            rcv_next_state <= check_lock;
         else
            rcv_next_state <= waiting;
      check_lock: 
         if (sin) 
            rcv_next_state <= waiting;
         else if (~sin) 
            rcv_next_state <= rcv_locked;
         else
            rcv_next_state <= check_lock;
      rcv_locked: 
         if (sample) 
            rcv_next_state <= read_data;
         else
            rcv_next_state <= rcv_locked;
      read_data: 
         if (~sample) 
            rcv_next_state <= incr_count2;
         else
            rcv_next_state <= read_data;
      incr_count2: 
         if (sample) 
            if (rcv_bit_cnt_cld == 7) 
               rcv_next_state <= done_read;
            else
               rcv_next_state <= read_data;
         else
            rcv_next_state <= incr_count2;
      done_read: 
         if (~sample) 
            rcv_next_state <= read_stop_bit;
         else
            rcv_next_state <= done_read;
      read_stop_bit: 
         if (sample) 
            rcv_next_state <= finish_rcv;
         else
            rcv_next_state <= read_stop_bit;
      finish_rcv: 
         rcv_next_state <= waiting;
      default: begin
         rcv_next_state = waiting;
      end
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Next State Block for machine xmit
//-----------------------------------------------------------------
always @(
   sample or 
   start_xmit or 
   xmit_bit_cnt or 
   xmit_current_state
)
begin : xmit_nextstate_proc
   case (xmit_current_state) 
      waiting_to_xmit: 
         if (start_xmit) 
            xmit_next_state <= send_start;
         else
            xmit_next_state <= waiting_to_xmit;
      send_start: 
         if (sample) 
            xmit_next_state <= send_data;
         else
            xmit_next_state <= send_start;
      send_data: 
         if (~sample) 
            xmit_next_state <= incr_count;
         else
            xmit_next_state <= send_data;
      incr_count: 
         if (sample) 
            if (xmit_bit_cnt == 0) 
               xmit_next_state <= done_xmit;
            else
               xmit_next_state <= send_data;
         else
            xmit_next_state <= incr_count;
      done_xmit: 
         if (~sample) 
            xmit_next_state <= send_stop_bit;
         else
            xmit_next_state <= done_xmit;
      send_stop_bit: 
         xmit_next_state <= finish_xmit;
      finish_xmit: 
         xmit_next_state <= waiting_to_xmit;
      default: begin
         xmit_next_state = waiting_to_xmit;
      end
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine rcv
//-----------------------------------------------------------------
always @(
   rcv_current_state or 
   sample or 
   sin
)
begin : rcv_output_proc
   // Default Assignment
   done_rcving <= 0;
   enable_rcv_clk <= 0;
   rcving <= 0;
   read_bit <= 0;

   // Combined Actions
   case (rcv_current_state) 
      waiting: begin
         if (~sin) begin 
            enable_rcv_clk <= 1;
         end
      end
      check_lock: begin
         enable_rcv_clk <= 1;
         if (sin) begin 
            enable_rcv_clk <= 0;
         end
         else begin
         end
      end
      rcv_locked: begin
         rcving <= 1;
         enable_rcv_clk <= 1;
      end
      read_data: begin
         rcving <= 1;
         enable_rcv_clk <= 1;
      end
      incr_count2: begin
         rcving <= 1;
         enable_rcv_clk <= 1;
         if (sample) begin 
            read_bit <= 1;
         end
      end
      done_read: begin
         rcving <= 1;
         enable_rcv_clk <= 1;
      end
      read_stop_bit: begin
         rcving <= 1;
         enable_rcv_clk <= 1;
      end
      finish_rcv: begin
         enable_rcv_clk <= 0;
         rcving <= 0;
         done_rcving <= 1;
      end
      default: begin
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Output Block for machine xmit
//-----------------------------------------------------------------
always @(
   xmit_current_state
)
begin : xmit_output_proc
   // Default Assignment
   done_xmitting <= 0;

   // Combined Actions
   case (xmit_current_state) 
      send_stop_bit: 
         done_xmitting <= 1;
      default: begin
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine rcv
//-----------------------------------------------------------------
always @(
   posedge clk or 
   negedge rst
) 
begin : rcv_clocked_proc
   if (!rst) begin
      rcv_current_state <= waiting;
      // Reset Values
      rcv_bit_cnt_cld <= 0;
   end
   else 
   begin
      rcv_current_state <= rcv_next_state;

      // Combined Actions
      case (rcv_current_state) 
         waiting: begin
            rcv_bit_cnt_cld <= 0;
            if (~sin) begin 
               rcv_bit_cnt_cld <= 0;
            end
         end
         incr_count2: begin
            if (sample) begin 
               if (!(rcv_bit_cnt_cld == 7)) begin 
                  rcv_bit_cnt_cld <= rcv_bit_cnt_cld + 1;
               end
            end
         end
         default: begin
         end
      endcase
   end
end // Clocked Block

//-----------------------------------------------------------------
// Clocked Block for machine xmit
//-----------------------------------------------------------------
always @(
   posedge clk or 
   negedge rst
) 
begin : xmit_clocked_proc
   if (!rst) begin
      xmit_current_state <= waiting_to_xmit;
      // Reset Values
      enable_xmit_clk_cld <= 0;
      sout_cld <= 1;
      xmitting_cld <= 0;
      xmit_bit_cnt <= 0;
   end
   else 
   begin
      xmit_current_state <= xmit_next_state;
      // Default Assignment To Internals
      sout_cld <= 1;

      // Combined Actions
      case (xmit_current_state) 
         waiting_to_xmit: 
            xmit_bit_cnt <= 0;
         send_start: begin
            sout_cld <= 0;
            enable_xmit_clk_cld <= 1;
            xmitting_cld <= 1;
         end
         send_data: begin
            sout_cld <= xmitdt[xmit_bit_cnt];
            if (~sample) begin 
               xmit_bit_cnt <= xmit_bit_cnt + 1;
            end
         end
         incr_count: 
            sout_cld <= xmitdt[xmit_bit_cnt];
         finish_xmit: begin
            enable_xmit_clk_cld <= 0;
            xmitting_cld <= 0;
         end
         default: begin
         end
      endcase
   end
end // Clocked Block

// Concurrent Statements
// Clocked output assignments
always @(
   enable_xmit_clk_cld or 
   rcv_bit_cnt_cld or 
   sout_cld or 
   xmitting_cld
)
begin : clocked_output_proc
   enable_xmit_clk <= enable_xmit_clk_cld;
   rcv_bit_cnt <= rcv_bit_cnt_cld;
   sout <= sout_cld;
   xmitting <= xmitting_cld;
end
endmodule // xmit_rcv_control

