//
// Module UART_V.control_operation.fsm
//
// Created:
//          by - user.group (host.domain)
//          at - 12:39:53 04/12/2005
//
// Generated by Mentor Graphics' HDL Designer(TM) 2005.1
//
`resetall
`timescale 1ns/10ps
module control_operation( 
   clk, 
   clr_int_en, 
   cs, 
   nrw, 
   rst, 
   xmitdt_en, 
   clear_flags, 
   enable_write, 
   start_xmit
);


// Internal Declarations

input   clk;
input   clr_int_en;
input   cs;
input   nrw;
input   rst;
input   xmitdt_en;
output  clear_flags;
output  enable_write;
output  start_xmit;


wire clk;
wire clr_int_en;
wire cs;
wire nrw;
wire rst;
wire xmitdt_en;
reg clear_flags;
reg enable_write;
reg start_xmit;
// Module Declarations

// State encoding
parameter [2:0]
          idle             = 3'd0,
          reading_from_reg = 3'd1,
          clearing_flags   = 3'd2,
          writing_to_reg   = 3'd3,
          xmitting         = 3'd4;

reg [2:0] current_state, next_state;
// pragma state_vector current_state

//-----------------------------------------------------------------
// Next State Block for machine cntrl_op
//-----------------------------------------------------------------
always @(
   clr_int_en or 
   cs or 
   current_state or 
   nrw or 
   xmitdt_en
)
begin : next_state_block_proc
   // Default Assignment
   clear_flags = 0;
   enable_write = 0;
   start_xmit = 0;

   // Combined Actions
   case (current_state) 
      idle: begin
         if (nrw  && ~cs)
            next_state = writing_to_reg;
         else if (~nrw && ~cs)
            next_state = reading_from_reg;
         else
            next_state = idle;
      end
      reading_from_reg: begin
         if (cs)
            next_state = idle;
         else if (~nrw && clr_int_en)
            next_state = clearing_flags;
         else
            next_state = reading_from_reg;
      end
      clearing_flags: begin
         clear_flags = 1;
         if (cs)
            next_state = idle;
         else
            next_state = clearing_flags;
      end
      writing_to_reg: begin
         enable_write = 1;
         if (cs)
            next_state = idle;
         else if (nrw && xmitdt_en)
            next_state = xmitting;
         else
            next_state = writing_to_reg;
      end
      xmitting: begin
         start_xmit = 1;
         if (cs)
            next_state = idle;
         else
            next_state = xmitting;
      end
      default: begin
         next_state = idle;
      end
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Clocked Block for machine cntrl_op
//-----------------------------------------------------------------
always @(
   posedge clk or 
   negedge rst
) 
begin : clocked_block_proc
   if (!rst) begin
      current_state <= idle;
   end
   else 
   begin
      current_state <= next_state;
   end
end // Clocked Block

endmodule // control_operation
