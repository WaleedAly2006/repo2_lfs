//
// Module UART_V.tester.flow
//
// Created:
//          by - user.group (host.domain)
//          at - 12:39:53 04/12/2005
//
// Generated by Mentor Graphics' HDL Designer(TM) 2005.1
//

`resetall
`timescale 1ns/10ps
module tester( 
   datout,  // 8-bit data out bus to cpu
   int,     // interrupt(1)
   sout,    // serial output
   addr,    // 3-bit address bus
   clk,     // 10 MHz clock
   cs,      // chip select
   datin,   // 8-bit data in bus from cpu
   nrw,     // read(0), write(1)
   rst,     // reset(0)
   sin      // serial input
);


// Internal Declarations

input  [7:0] datout;
input        int;
input        sout;
output [2:0] addr;
output       clk;
output       cs;
output [7:0] datin;
output       nrw;
output       rst;
output       sin;


wire [7:0] datout;
wire int;
wire sout;
reg [2:0] addr;
reg clk;
reg cs;
reg [7:0] datin;
reg nrw;
reg rst;
reg sin;
// pragma synthesis_off
reg tester_top_hds_animation_indicator;
// pragma synthesis_on

// Module declarations
parameter CLK_PRD = 100 ;
parameter RCV_CLK_PRD = (CLK_PRD * 6);

reg [7:0] DIV_LSB, DIV_MSB, SER_DATA, XMIT_DATA;
reg int_clk;

reg [7:0] read_data;
integer i;
// ---------------------
//    UART_WRITE
// ---------------------
task uart_write;
   input [7:0] bit_data;
   input [2:0] addr_w;
begin
   addr = addr_w;
   nrw = # (CLK_PRD) 1;
   datin = bit_data;
   cs = #(CLK_PRD) 0;
   cs = #(5*CLK_PRD) 1;
   nrw = #(CLK_PRD) 0;
   # CLK_PRD;
end
endtask

// ---------------------
//    UART_READ
// ---------------------
task uart_read ;
input [2:0] addr_r;
begin
    addr = addr_r;
    nrw = #( 2*CLK_PRD) 0 ;
    cs = #(CLK_PRD) 0;
    #(9*CLK_PRD);
    read_data = datout;
    cs = #(2*CLK_PRD) 1 ; 
    #CLK_PRD;
 end
endtask

/////////////////////////////////////////////////////////////////
// Flowchart tester_top
initial 
begin : tester_top_flowchart_proc
   // pragma synthesis_off
   $hdsCurrentPath(0,1);
   // pragma synthesis_on
   // pragma synthesis_off
   $hdsCurrentPath(0,2);
   // pragma synthesis_on
   int_clk = 0;
   DIV_LSB = 8'b00000110;
   DIV_MSB = 8'b0;
   SER_DATA = 8'b11001110;
   XMIT_DATA = 8'b01011010;
   cs = 1;
   nrw = 0;
   addr = "000";
   sin = 1;
   rst = 0;
   datin = # CLK_PRD 8'b00000000;
   rst = # (CLK_PRD) 1 ;
   // pragma synthesis_off
   $hdsCurrentPath(0,3);
   // pragma synthesis_on
   # (3*CLK_PRD);
   // pragma synthesis_off
   $hdsCurrentPath(0,4);
   // pragma synthesis_on
   uart_write(DIV_LSB,0);
   // pragma synthesis_off
   $hdsCurrentPath(0,5);
   // pragma synthesis_on
   # (7*CLK_PRD);
   // pragma synthesis_off
   $hdsCurrentPath(0,6);
   // pragma synthesis_on
   uart_write(DIV_MSB,1);
   // pragma synthesis_off
   $hdsCurrentPath(0,7);
   // pragma synthesis_on
   # (7*CLK_PRD);
   // pragma synthesis_off
   $hdsCurrentPath(0,8);
   // pragma synthesis_on

   // pragma synthesis_off
   $hdsCurrentPath(0,9);
   // pragma synthesis_on
   uart_write(XMIT_DATA,4);
   // pragma synthesis_off
   $hdsCurrentPath(0,10);
   // pragma synthesis_on
   for (i=0;i<60;i=i+1) begin
      // pragma synthesis_off
      $hdsCurrentPath(0,11);
      // pragma synthesis_on
      if (int==1) begin
         // pragma synthesis_off
         $hdsCurrentPath(0,12);
         // pragma synthesis_on
         i = 60;
      end
      else
      begin
         // pragma synthesis_off
         $hdsCurrentPath(0,13);
         // pragma synthesis_on
         #CLK_PRD;
      end
   // pragma synthesis_off
   $hdsCurrentPath(0,14);
   // pragma synthesis_on
   end
   // pragma synthesis_off
   $hdsCurrentPath(0,15);
   // pragma synthesis_on
   if (int==1 && i != 60) begin
      // pragma synthesis_off
      $hdsCurrentPath(0,16);
      // pragma synthesis_on
      wait (int_clk == 0 || int_clk);
      // pragma synthesis_off
      $hdsCurrentPath(0,17);
      // pragma synthesis_on
      uart_read(7);
   end
   else
   begin
      // pragma synthesis_off
      $hdsCurrentPath(0,18);
      // pragma synthesis_on
      wait (int_clk == 0 || int_clk);
      // pragma synthesis_off
      $hdsCurrentPath(0,19);
      // pragma synthesis_on
      $display("Interrupt did not occur");
   end

   // pragma synthesis_off
   $hdsCurrentPath(0,20);
   // pragma synthesis_on

   // pragma synthesis_off
   $hdsCurrentPath(0,21);
   // pragma synthesis_on
   sin = 0;
   // pragma synthesis_off
   $hdsCurrentPath(0,22);
   // pragma synthesis_on
   # (3*CLK_PRD);
   // pragma synthesis_off
   $hdsCurrentPath(0,23);
   // pragma synthesis_on
   for (i=0;i<8;i=i+1) begin
      // pragma synthesis_off
      $hdsCurrentPath(0,24);
      // pragma synthesis_on
      sin <= SER_DATA[i];
      // pragma synthesis_off
      $hdsCurrentPath(0,25);
      // pragma synthesis_on
      # (6*CLK_PRD);
   // pragma synthesis_off
   $hdsCurrentPath(0,26);
   // pragma synthesis_on
   end
   // pragma synthesis_off
   $hdsCurrentPath(0,27);
   // pragma synthesis_on
   sin = 1;
   // pragma synthesis_off
   $hdsCurrentPath(0,28);
   // pragma synthesis_on
   # (10*CLK_PRD);
   // pragma synthesis_off
   $hdsCurrentPath(0,29);
   // pragma synthesis_on
   uart_read(7);
   // pragma synthesis_off
   $hdsCurrentPath(0,30);
   // pragma synthesis_on
   uart_read(5);
   // pragma synthesis_off
   $hdsCurrentPath(0,31);
   // pragma synthesis_on
   if (!(read_data == SER_DATA)) begin
      // pragma synthesis_off
      $hdsCurrentPath(0,32);
      // pragma synthesis_on
      $display( "Read Data did NOT equal Serial Data");
   end

   // pragma synthesis_off
   $hdsCurrentPath(0,33);
   // pragma synthesis_on

   // pragma synthesis_off
   $hdsCurrentPath(0,34);
   // pragma synthesis_on
   uart_read(6);
   // pragma synthesis_off
   $hdsCurrentPath(0,35);
   // pragma synthesis_on
   if (!(read_data == 8'b0)) begin
      // pragma synthesis_off
      $hdsCurrentPath(0,36);
      // pragma synthesis_on
      $display("Status NOT zero");
   end

   // pragma synthesis_off
   $hdsCurrentPath(0,37);
   // pragma synthesis_on
   $display("Uart Testing Complete");
   $stop;
   // pragma synthesis_off
   $hdsCurrentPath(0,38);
   // pragma synthesis_on
end

// Concurrent statements
// Clock Generator
initial
   begin : clk_gen1_proc
      int_clk = 0;
      forever #(CLK_PRD/2) int_clk = ~int_clk;
   end

always @(int_clk)
   begin : clk_gen2_proc
      clk = int_clk;
   end

endmodule // tester

